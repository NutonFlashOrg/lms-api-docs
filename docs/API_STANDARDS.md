# Стандарты REST API

Этот документ описывает единые правила для разработки и использования REST API в нашем проекте (Fastify JS + Ajv + @fastify/swagger + Prisma + BullMQ + SSE).

## 1. Общие принципы

- **Явные контракты**: каждый роут имеет JSON Schema для body/query/params/response. Swagger/OpenAPI генерируется автоматически.
- **Стабильная форма ответа**: единый «envelope» для успеха и ошибок.
- **Чёткие коды статусов**: используем стандартные HTTP-коды, без «магии».
- **Предсказуемые пагинация/фильтры/сортировка**.
- **Нейтральные названия и согласованные типы**: ISO 8601 для дат, числа — без строк, булевы — истинные булевы.
- **Версионирование**: префикс `/v1` в пути. Изменения контракта — через новую версию.

## 2. Формат ответа (envelope)

### 2.1 Успех

```jsonc
{
  "success": true,
  "data": {
    /* объект или массив */
  },
  "meta": {
    /* опционально: пагинация, сортировка, тайминги */
  },
}
```

- **GET single**: `data` — объект.
- **GET list**: `data` — массив объектов; `meta.pagination` присутствует.
- **POST create**: `201 Created`, `Location` заголовок → URL созданного ресурса; `data` — созданный объект.
- **PUT/PATCH update**: `200 OK` с обновлённым объектом (или `204 No Content` без тела — по решению модуля).
- **DELETE**: `204 No Content` (если удалено), `404` (если ресурса нет).

#### Использование `Location`

Заголовок `Location` всегда возвращается при успешном создании ресурса (`201 Created`).

- Он содержит канонический URL только что созданного объекта: `/v1/collection/:id`.
- Это позволяет фронтенду:
  - сразу знать адрес для дальнейших запросов (GET, PATCH, DELETE);
  - отобразить или сохранить ссылку без дополнительного запроса;
  - при повторной отправке того же POST сервер может вернуть тот же `Location`, что помогает избежать дубликатов.

- Пример:

```
HTTP/1.1 201 Created
Location: /v1/practices/p_123
Content-Type: application/json

{
  "success": true,
  "data": { "id": "p_123", "title": "Практика" }
}
```

### 2.2 Ошибка

```jsonc
{
  "success": false,
  "error": {
    "code": "BAD_REQUEST",
    "message": "Некорректные входные данные",
    "details": [{ "path": "body.title", "message": "Обязательное поле" }],
    "traceId": "c9d0b1...",
  },
}
```

- `code` — машинно-читабельный код из таблицы ниже.
- `message` — лаконично для пользователя/фронта.
- `details` — массив с описанием полей/причин (для валидации и бизнес-правил).
- `traceId` — кореляционный ID запроса (логируется Pino, см. ниже).

## 3. HTTP-коды и когда их возвращать

### 2xx

- **200 OK** — успешный запрос (GET/PUT/PATCH), тело с `data`.
- **201 Created** — ресурс создан (POST). Заголовок `Location` обязателен.
- **202 Accepted** — задача принята в обработку асинхронно (редко, например, запуск фоновой job).
- **204 No Content** — успешный запрос без тела (DELETE, иногда PATCH/PUT).

### 4xx (ошибки клиента)

- **400 Bad Request** — синтаксис запроса неверный или данные не проходят валидацию (JSON не парсится, неверный формат UUID/даты, бизнес-правила не соблюдены и т.п.). `code=BAD_REQUEST`.
- **401 Unauthorized** — нет или просрочен JWT/недействителен Telegram initData. `code=UNAUTHORIZED`.
- **403 Forbidden** — JWT есть, но нет прав на действие/ресурс. `code=FORBIDDEN`.
- **404 Not Found** — ресурс не найден (id отсутствует). `code=NOT_FOUND`.
- **409 Conflict** — конфликт состояния/уникальности (дубликат, занятый слот роли, попытка начать практику без полного комплекта и т.п.). `code=CONFLICT`.
- **429 Too Many Requests** — лимит по rate limit. `code=RATE_LIMITED`.

### 5xx (ошибки сервера)

- **500 Internal Server Error** — непредвиденная ошибка. `code=INTERNAL_ERROR`, без лишних подробностей.
- **503 Service Unavailable** — временная недоступность/деградация (например, БД/кэш). `code=UNAVAILABLE`.

## 4. Пагинация, фильтрация, сортировка

### 4.1 Пагинация (cursor-based)

Мы используем курсорную пагинацию (seek-pagination), а не page+limit, чтобы избежать проблем со «скачущими» страницами при изменении данных.
Поддерживается навигация вперёд и назад.

Запрос:

`GET /v1/lessons?limit=20&cursor=l_123&dir=next&by=createdAt&order=asc`

Где:

- **cursor** — идентификатор последнего объекта на предыдущей странице (обычно id).
- **dir** — направление выборки: next (по умолчанию) или prev.
- **by** — поле сортировки.
- **order** — порядок: asc или desc.

Ответ:

```jsonc
{
  "success": true,
  "data": [
    /* элементы */
  ],
  "meta": {
    "pagination": {
      "limit": 20,
      "prevCursor": "l_101",
      "nextCursor": "l_140",
      "hasPrev": true,
      "hasNext": true,
      "total": 250, // если withCount=true
      "totalPages": 13, // если withCount=true
      "dir": "next",
    },
    "sort": { "by": "createdAt", "order": "asc" },
    "filters": {
      /* отражаем применённые фильтры или null */
    },
  },
}
```

- prevCursor и nextCursor позволяют ходить в обе стороны.
- hasPrev и hasNext явно указывают, есть ли страницы слева/справа.
- При withCount=true возвращаются total и totalPages.
- Если элементов больше нет, соответствующий cursor отсутствует.

### 4.2 Фильтры

- Передаём простыми query-параметрами:`?state=PLANNED&from=2025-09-29T00:00:00Z&to=2025-09-30T00:00:00Z`.
- Массивы — повторением ключа:`?role=SELLER&role=BUYER`.

### 4.3 Сортировка

- Передаём отдельными параметрами:
  - `by=createdAt`
  - `rder=asc|desc`
- Поле by определяет ключ сортировки.
- Порядок order задаёт направление сортировки.

## 5. TraceId: как и зачем

- **Генерация**: traceId создаётся при каждом входящем запросе (например, UUID v4).
- **Использование**:
  - добавляется в заголовок ответа `X-Trace-Id`;
  - логируется во все записи Pino по данному запросу;
  - в случае ошибки добавляется также в `error.traceId` в теле ответа.

- **Зачем**: фронт или поддержка могут передать traceId в баг-репорте; по нему легко найти все связанные логи в системе.
- **Dev vs Prod**:
  - **Dev**: можно добавлять расширенные детали (`stack`), чтобы быстрее отлаживать.
  - **Prod**: возвращаем только `message`, `code` и `traceId`. Стектрейсы — только в логах.

## 6. Правила для CRUD

### 6.1 GET /collection (getAll)

- `200 OK`
- `data` — массив объектов. Если нет записей — пустой массив `[]` (не `null`).
- `meta.pagination` присутствует всегда при пагинируемых запросах.

### 6.2 GET /collection/:id (getSingle)

- Если найдено — `200 OK` + объект в `data`.
- Если не найдено — `404 Not Found`.

### 6.3 POST /collection (create)

- Валидация body по JSON Schema.
- При успехе — `201 Created`, `Location: /v1/collection/:id`, `data` — созданный объект.
- Конфликты уникальности — `409 Conflict`.

### 6.4 PUT /collection/:id (replace)

- Полная замена ресурса. Все обязательные поля должны присутствовать в body.
- `200 OK` с объектом в `data` или `204 No Content` (без тела) — выбрать единый подход per-модуль и придерживаться.
- Не найдено — `404 Not Found`.

### 6.5 PATCH /collection/:id (partial update)

- Изменение подмножества полей.
- `200 OK` (или `204 No Content`) по договорённости модуля.
- Не найдено — `404 Not Found`.

### 6.6 DELETE /collection/:id

- Успех — `204 No Content`.
- Не найдено — `404 Not Found`.
- Конфликт (например, нарушается FK-целостность) — `409 Conflict`.

## 7. Семантика ошибок и коды `error.code`

| HTTP | code           | Когда                                                              |
| ---: | -------------- | ------------------------------------------------------------------ |
|  400 | BAD_REQUEST    | Невалидный JSON, неверные типы/форматы, несоблюдение бизнес-правил |
|  401 | UNAUTHORIZED   | Нет/некорректный JWT, проваленная проверка Telegram initData       |
|  403 | FORBIDDEN      | Недостаточно прав (RBAC), запрет к ресурсу                         |
|  404 | NOT_FOUND      | Ресурс не существует                                               |
|  409 | CONFLICT       | Дубликаты/конфликт состояний (занятый слот роли, уникальный ключ)  |
|  429 | RATE_LIMITED   | Превышены лимиты частоты запросов                                  |
|  500 | INTERNAL_ERROR | Необработанная ошибка                                              |
|  503 | UNAVAILABLE    | Временная недоступность зависимостей                               |

## 8. Специфика проекта

### 8.1 Lessons (JSON-блоки)

- В ответах `GET /lessons/:id/view` сервер разворачивает `assetId` в `resolvedUrl` (presigned) и валидирует `externalUrl` по allow-list.
- При `PATCH /lessons/:id` сохраняется поле `content` целиком согласно JSON Schema. Ошибки структуры → `400 BAD_REQUEST`.

### 8.2 Practices

- Бизнес-предусловия (слоты ролей, статусы) → при нарушении `409 CONFLICT`.

### 8.3 Evaluations

- Нельзя оценивать себя → `400 BAD_REQUEST` с `details`.
- Повторная сдача, если запрещена → `409 CONFLICT`.

## 9. Аутентификация и авторизация

- Авторизация — Bearer JWT (после верификации Telegram initData). `401` если токена нет/недействителен. `403` если роль не допускает действие.
- В ответ добавляем заголовок `WWW-Authenticate: Bearer` при `401` (рекомендовано).

## 10. Заголовки и дата/время

- Все даты/время — **UTC ISO 8601** (`2025-09-29T03:00:00Z`).
- Для кэшируемых GET (где это уместно) поддерживаем `ETag`/`If-None-Match` (возвращаем `304 Not Modified`).
- Для идемпотентных POST (по необходимости) поддерживаем `Idempotency-Key` (возвращаем тот же результат при повторе).

## 11. SSE

- Эндпоинт вида: `GET /v1/sse/practices/:id`.
- Заголовки: `Content-Type: text/event-stream`, `Cache-Control: no-cache`, `Connection: keep-alive`.
- Формат события:

```
event: practice-started
data: {"practiceId":"...","at":"2025-09-29T03:00:00Z"}

```

- При обрыве фронт переоткрывает соединение (экспоненциальная задержка).

## 12. Документация и примеры

- Swagger UI: `/docs`, OpenAPI JSON: `/openapi.json`.
- Для каждого роута — пример запроса/успеха/ошибки в Swagger (response examples).

## 13. Логи и трассировка

- Каждый запрос получает `traceId` (кореляционный ID).
- В dev окружении можно возвращать расширенные детали (например, стектрейсы).
- В prod окружении — только безопасные сообщения и `traceId`. По нему ищем ошибки в логах.

## 14. Депрекации и версии

- Изменения контракта — только через новую версию (`/v2`).
- Старые версии помечаем deprecated в Swagger, объявляем срок вывода.

---

### Примеры

**Успешный список**

```jsonc
{
  "success": true,
  "data": [{ "id": "l_1", "title": "Урок 1" }],
  "meta": { "pagination": { "limit": 20, "nextCursor": "abc" } },
}
```

**Создание с Location**

```
HTTP/1.1 201 Created
Location: /v1/lessons/l_1
Content-Type: application/json

{
  "success": true,
  "data": { "id": "l_1", "title": "Урок 1" }
}
```

**Не найдено**

```jsonc
{
  "success": false,
  "error": { "code": "NOT_FOUND", "message": "Ресурс не найден", "traceId": "c9d0b1" },
}
```

**Валидация**

```jsonc
{
  "success": false,
  "error": {
    "code": "BAD_REQUEST",
    "message": "Некорректные входные данные",
    "details": [{ "path": "body.startAt", "message": "date-time ожидается" }],
    "traceId": "c9d0b1",
  },
}
```
