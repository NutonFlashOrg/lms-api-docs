# Авторизация: краткое руководство для фронтенда

Этот гайд по нашей системе авторизации. Он описывает, как фронтенду правильно взаимодействовать с бэкендом, какие эндпоинты вызывать, какие токены используются, как работают приглашения и какой рекомендуемый порядок действий на старте приложения.

## Обзор

**Данные для энтри поинта:** Telegram WebApp initData (криптоподписанная строка от Telegram).

**Сессии:** короткоживущий Access JWT (+ используется в Authorization: Bearer), и долгоживущий Refresh JWT в HttpOnly cookie refresh_token.

**Инвайты:** первый вход строго по приглашению (Invite) на Telegram-юзернейм.

**Рекомендованный старт:** сначала пробуем тихий refresh, если не получилось — отправляем initData на /v1/auth/telegram.

## Маршруты (эндпоинты)

### 1) POST /v1/auth/refresh — тихое продление сессии

**Назначение:** если в браузере есть валидная cookie refresh_token, сервер:

- проверяет её на подпись/срок/отзыв в БД,
- ротирует (выдаёт новую cookie),
- возвращает новый Access JWT.

**Тело запроса:** нет.

**Аутентификация:** cookie refresh_token отправится автоматически (если same-origin).

**Ответ 200 OK (успех):**

```json
{
  "success": true,
  "data": {
    "accessToken": "<JWT>",
    "expiresIn": 900
  }
}
```

**Ответ 401 (ошибка):** нет или невалидный refresh → переходите на /v1/auth/telegram.

Для Swagger, если браузер не подцепил cookie, можно передать X-Refresh-Token заголовком.

### 2) POST /v1/auth/telegram — вход по Telegram initData + логика инвайтов

**Назначение:** "холодный старт" (когда refresh недоступен). Сервер:

- валидирует initData (подпись и валидность),
- извлекает telegramId и username,
- применяет правила инвайтов,
- создаёт (или находит) пользователя,
- выдаёт Access JWT + устанавливает HttpOnly refresh cookie.

**Body:**

```json
{ "initData": "<строка, которую даёт Telegram WebApp>" }
```

**Поведение по инвайту:**

- **Если пользователь уже существует** (нашёлся по telegramId):
  — обновляем username при необходимости, выдаём токены.

- **Если пользователь НЕ существует:**
  — ищем PENDING инвайт по targetUsername (вашему username в TG), проверяем expiresAt (если просрочен — ошибка),
  — создаём пользователя, устанавливаем роль из типа инвайта, помечаем инвайт как ACCEPTED,
  — выдаём токены.

- **Если PENDING инвайта нет** → 401 (нет валидного приглашения → вход запрещён).

**Ответ 200 OK (успех):**

```json
{
  "success": true,
  "data": {
    "accessToken": "<JWT>",
    "expiresIn": 900
  }
}
```

Плюс в ответе будет заголовок `Set-Cookie: refresh_token=...; HttpOnly; Secure; SameSite=Strict; Path=/v1/auth; Max-Age=<30 дней>`.

**Ошибки (типовые):**

- 401 UNAUTHORIZED — невалидная подпись initData / нет PENDING инвайта / инвайт просрочен.
- 400 BAD_REQUEST — нет поля initData или формат неверный.

**Роли при первом входе:** берутся из инвайта (ADMIN / CLIENT_OWNER / MOP). При последующих входах роль читается из пользователя (может быть изменена в админке).

### 3) POST /v1/auth/logout — выход (отзыв refresh)

**Назначение:** отозвать текущий refresh и очистить cookie.

**Тело запроса:** нет.

**Аутентификация:** cookie refresh_token (или X-Refresh-Token).

**Ответ 204 No Content (успех):** cookie очищена, refresh отозван.

**Итог:** следующий /v1/auth/refresh вернёт 401, а холодный запуск пойдёт через /v1/auth/telegram.

## Глобальная защита маршрутов

Все бизнес-эндпоинты (например, /v1/clients, /v1/users, и т.п.) закрыты глобальным middleware и требуют `Authorization: Bearer <accessToken>`.

- При отсутствии/просрочке/невалидности — 401.
- При недостатке прав (роль не подходит) — 403.

## Жизненный цикл токенов

**Access JWT** — срок 1 день. Отправляется клиентом в заголовке `Authorization: Bearer ...` при каждом запросе к защищённым API.

**Refresh JWT** — срок ~30 дней, хранится на клиенте только в HttpOnly cookie refresh_token, и автоматически отправляется только на эндпоинты /v1/auth/\*.

**Ротация refresh:** при каждом успешном /v1/auth/refresh сервер создаёт новый refresh, старый помечает отозванным (single-session per cookie). При входе через /v1/auth/telegram мы не принудительно отзываем прежние refresh'и (разрешаем несколько сессий на разных устройствах); при необходимости это можно изменить политикой.

## Рекомендуемая последовательность на запуске:

1. **Пробуем refresh:**
   Вызвать POST /v1/auth/refresh.
   — Если 200, используем выданный accessToken и работаем.
   — Если 401, переходим к шагу 2.

2. **Падаем обратно на Telegram вход:**
   Вызвать POST /v1/auth/telegram с initData.
   — Если всё хорошо, сервер выдаст accessToken и установит новую refresh_token cookie.

3. **Дальше:**
   - Все защищённые запросы отправлять с заголовком `Authorization: Bearer <accessToken>`.
   - Если со временем получите 401 (access истёк), повторно вызовите /v1/auth/refresh.

**Псевдо:**

```
onAppOpen:
  try POST /v1/auth/refresh
    if 200 -> use accessToken
    if 401 -> POST /v1/auth/telegram { initData } -> use accessToken
```

## Что важно учесть на фронте

- Access не "прикрепляется сам" — всегда добавляйте `Authorization: Bearer ...`.
- Refresh хранится и отправляется браузером автоматически (HttpOnly cookie) только на пути /v1/auth/\*. JS его не видит.
- initData даёт Telegram Mini App при запуске. Используйте его только при холодном старте (или всегда, если выберете самый простой вариант без шага refresh).
- Username в Telegram может меняться — это нормально; идентификация всегда по telegramId.

## Быстрые примеры (Swagger/Postman)

### Обновление сессии (успех)

```
POST /v1/auth/refresh
Cookie: refresh_token=<...>

200
{
  "success": true,
  "data": { "accessToken": "<JWT>", "expiresIn": 900 }
}
```

### Обновление сессии (нужно зайти через Telegram)

```
POST /v1/auth/refresh
Cookie: (отсутствует/просрочена)

401
{
  "success": false,
  "error": { "code": "UNAUTHORIZED", "message": "..." }
}
```

### Вход по Telegram

```
POST /v1/auth/telegram
Content-Type: application/json

{ "initData": "<querystring от Telegram>" }

200
Set-Cookie: refresh_token=...; HttpOnly; Secure; SameSite=Strict; Path=/v1/auth; Max-Age=2592000
{
  "success": true,
  "data": { "accessToken": "<JWT>", "expiresIn": 900 }
}
```

### Выход

```
POST /v1/auth/logout
Cookie: refresh_token=<...>

204 (без тела)
```

## Возможные вопросы

**Что такое инвайты и как они работают**
На самом деле для тебя как для фронтэндера, вообще без разницы. Мы используем систему инвайтов на бэке чтобы трэкать заходил ли уже человек и валидировать приглашения.
логика там пока не доконца дописана, так как еще не готовы лицензии, но базово работающая версия будет выглядеть примерно так

**Нужно ли фронту решать "первый раз / не первый"?**
Нет. Cначала refresh, если не вышло — telegram. Сервер сам разрулит.

**Что, если инвайт просрочен / отменён?**
/v1/auth/telegram вернёт ошибку (401/410 в зависимости от состояния). Токены не выдаются.

**Мульти-девайс:**
Сейчас политика допускает несколько активных refresh-cookie на разных устройствах (при входе через /v1/auth/telegram старые не отзываются). При refresh происходит ротация конкретной cookie (старый jti помечается отозванным).
